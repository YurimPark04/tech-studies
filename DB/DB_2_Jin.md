## 1. 관계형DB와 NoSQL의 차이점

**관계형 데이터베이스 (RDBMS)**:
- **구조**: 데이터를 테이블(행, 열) 형식으로 저장하며, 각 테이블 간의 관계를 정의합니다.
- **스키마**: 고정된 스키마를 따르며, 데이터는 미리 정의된 테이블 구조에 맞춰 저장됩니다.
- **쿼리 언어**: SQL(Structured Query Language)을 사용하여 데이터를 관리하고 질의합니다.
- **ACID**: 트랜잭션 처리에 있어 ACID(Atomicity, Consistency, Isolation, Durability)를 준수합니다.
- **예시**: MySQL, PostgreSQL, Oracle, SQL Server.

**NoSQL 데이터베이스**:
- **구조**: 관계형 데이터베이스와 달리 테이블 형태로 데이터를 저장하지 않고, 키-값, 도큐먼트, 컬럼 패밀리, 그래프 등 다양한 구조로 데이터를 저장합니다.
- **스키마**: 스키마가 유연하여, 저장되는 데이터의 형태나 구조가 동적으로 변할 수 있습니다.
- **쿼리 언어**: SQL 대신에 각 NoSQL DB마다 특화된 쿼리 방식이 존재합니다.
- **CAP 이론**: Consistency(일관성), Availability(가용성), Partition Tolerance(파티션 내구성) 중 2개를 선택해야 하며, 일관성을 약간 희생하고 성능을 우선시하는 경우가 많습니다.
- **예시**: MongoDB, Cassandra, Redis, Couchbase.

---

## 2. 인덱스의 정의와 B-트리 방법

**인덱스의 정의**:
- 인덱스는 데이터베이스에서 데이터를 빠르게 검색할 수 있도록 돕는 자료구조입니다. 일반적으로 테이블의 특정 열에 대해 생성되며, 해당 열의 값을 기준으로 빠르게 데이터를 찾을 수 있게 해줍니다. 
- 인덱스를 사용하면 테이블에서 데이터를 검색할 때 디스크 I/O를 줄여 성능을 향상시킬 수 있습니다.

**B-트리 방법**:
- B-트리는 균형 잡힌 다중 검색 트리로, 데이터를 정렬하여 트리 구조로 저장하고, 트리의 높이를 최소화하여 검색, 삽입, 삭제의 시간 복잡도를 O(log N)으로 유지합니다.
- **구성**: 노드에 다수의 키와 자식 포인터를 저장하여, 균형 잡힌 트리를 유지하면서 효율적으로 데이터를 검색합니다.
- **특징**: 모든 리프 노드가 동일한 깊이를 가지며, 삽입과 삭제가 일어나도 트리가 균형을 유지하여 성능이 일정하게 유지됩니다.

## 3. 조인의 원리와 중첩 루프, 정렬 병합, 해시 조인

**조인의 원리**:
- **조인**은 여러 테이블의 데이터를 연결하여 하나의 결과 집합을 만드는 작업입니다. 기본적으로 공통된 키(예: 외래 키)를 기준으로 데이터를 결합합니다.
- **종류**: 내츄럴 조인, 내적 조인(Inner Join), 외적 조인(Outer Join), 교차 조인(Cross Join) 등이 있습니다.

**중첩 루프 조인 (Nested Loop Join)**:
- 가장 간단한 조인 알고리즘으로, 하나의 테이블을 외부 루프(Outer loop)로, 다른 테이블을 내부 루프(Inner loop)로 하여 각 행을 비교하면서 조인합니다.
- **시간 복잡도**: O(N * M) (두 테이블의 크기)
- 작은 테이블에서 효율적입니다.

**정렬 병합 조인 (Sort-Merge Join)**:
- 두 테이블을 각각 정렬한 후, 정렬된 데이터를 병합하여 조인합니다.
- **시간 복잡도**: O(N log N) + O(M log M) (정렬 후 병합)
- 데이터가 이미 정렬되어 있거나, 정렬된 인덱스를 사용할 수 있을 때 효율적입니다.

**해시 조인 (Hash Join)**:
- 한 테이블을 해시 테이블에 저장하고, 다른 테이블을 순차적으로 스캔하여 해시 값이 일치하는 레코드를 찾는 방식입니다.
- **시간 복잡도**: O(N + M)
- 큰 테이블을 다룰 때 효율적이며, 메모리에서 처리되므로 빠른 성능을 보입니다.

## 4. 인덱스를 생성 후 최적화하는 방법

- **인덱스 재구성 및 재빌드**: 인덱스가 시간이 지나면서 단편화가 발생할 수 있습니다. 이를 재구성하거나 재빌드하여 성능을 최적화합니다.
- **사용되지 않는 인덱스 제거**: 사용되지 않는 인덱스를 제거하여 데이터베이스의 성능을 개선할 수 있습니다.
- **통계 정보 업데이트**: 데이터베이스의 통계 정보를 업데이트하여 쿼리 최적화기가 더 나은 실행 계획을 선택할 수 있도록 합니다.
- **인덱스 선택**: 자주 사용되는 쿼리의 조건에 맞는 인덱스를 선택적으로 생성하여 성능을 개선합니다. 예를 들어, 자주 검색되는 열이나 JOIN 조건에 인덱스를 추가합니다.
- **복합 인덱스 사용**: 여러 컬럼을 포함하는 복합 인덱스를 사용하여 쿼리 성능을 최적화할 수 있습니다.

## 5. 인덱스를 매 필드마다 설정하는 것은 성능에 유리한가?

**답변**:
- 매 필드마다 인덱스를 설정하는 것은 성능에 유리하지 않습니다. 과도한 인덱스는 데이터베이스 성능을 오히려 저하시킬 수 있습니다.
- **장점**: 인덱스가 있으면 해당 필드로 검색할 때 빠르게 데이터를 찾을 수 있습니다.
- **단점**: 각 인덱스는 추가적인 저장 공간을 요구하며, 데이터를 삽입, 업데이트, 삭제할 때마다 인덱스도 갱신해야 하므로 성능에 부담을 줄 수 있습니다.
- **추천**: 자주 조회되는 필드나 조건절에서 사용되는 필드에 인덱스를 설정하는 것이 유리합니다. 또한 복합 인덱스를 활용하여 여러 필드에 대한 효율적인 쿼리 성능을 도모할 수 있습니다.


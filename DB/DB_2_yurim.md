# 데이터베이스 인덱스 및 알고리즘 정리

## 1. 인덱스는 어떤 알고리즘으로 동작하나요?
인덱스는 데이터를 빠르게 검색하기 위해 **트리 구조 (B-Tree, B+Tree)** 또는 **해시 테이블**과 같은 알고리즘을 사용한다.  
- **B-Tree / B+Tree**: 계층적 구조를 가지며 범위 검색 및 정렬이 효율적이다.  
- **해시 테이블**: 키-값 매핑을 이용하여 특정 값을 빠르게 찾을 수 있지만, 범위 검색에는 적합하지 않다.  
- **비트맵 인덱스**: 값이 제한적인 경우(예: 성별, 국가 코드)에 유용하며, 특정 조건의 데이터를 빠르게 필터링할 수 있다.  

일반적으로 범위 검색과 정렬이 중요한 **관계형 데이터베이스(RDBMS)**에서는 **B-Tree 계열**이 가장 많이 사용된다.  

---

## 2. B-Tree 알고리즘에 대해 간략히 설명해주세요
B-Tree는 **균형 트리(Balanced Tree)**로, 검색, 삽입, 삭제 연산의 시간 복잡도가 **O(log N)**이다.  
- 각 노드에 여러 개의 키(key)와 자식 노드(child)가 존재하며, 이진 탐색 트리보다 **트리의 높이가 낮아** 검색 속도가 빠르다.  
- 노드가 가득 차면 **분할(split)**, 너무 적어지면 **병합(merge)**이 발생하여 항상 균형을 유지한다.  
- 범위 검색과 정렬이 필요할 때 효율적이다.  

---

## 3. B+Tree 알고리즘에 대해서도 간략히 알고 있다면, 설명해주세요
B+Tree는 B-Tree의 확장 버전으로, **리프 노드(leaf node)들만 데이터 값을 저장**하며, **리프 노드끼리 연결된 구조**를 가진다.  
- **장점:**  
  - 모든 데이터가 **리프 노드에 저장**되므로 검색 속도가 일정하다.  
  - **리프 노드가 Linked List 형태**로 연결되어 있어 **범위 검색(range query)**에 최적화되어 있다.  
  - 내부 노드는 **오직 키(key)만 저장**하므로, 같은 높이의 B-Tree보다 **더 많은 키를 저장**할 수 있어 트리의 높이가 낮다.  

MySQL과 같은 DBMS에서 B+Tree 인덱스를 많이 사용한다.  

---
## 4. 왜 DB 인덱스 알고리즘으로 B-Tree 인덱스를 선택했을까요?
1. **O(log N)의 안정적인 성능**: 트리의 높이가 낮아 균일한 성능을 보장한다.  
2. **범위 검색과 정렬에 강함**: ORDER BY, BETWEEN 연산을 최적화할 수 있다.  
3. **동적 데이터 삽입/삭제에 유리**: 균형을 유지하며 데이터 변경에 효율적으로 대응한다.  
4. **디스크 접근 최소화**: 한 번의 디스크 접근으로 많은 데이터를 읽을 수 있어 성능이 향상된다.  

이런 특성 때문에 DBMS는 해시 테이블 대신 **B-Tree 또는 B+Tree**를 인덱스로 사용한다.  

---

## 5. 왜 해시테이블은 선호되지 않나요?
해시 인덱스는 특정 키 값을 빠르게 찾을 때 유용하지만, RDBMS의 전형적인 **검색 패턴에 적합하지 않다**.  
1. **범위 검색이 불가능**: 해시는 특정 키에 대한 값만 찾을 수 있고, `BETWEEN`과 같은 범위 검색이 불가능하다.  
2. **정렬 지원 X**: 해시 테이블은 내부적으로 순서를 보장하지 않아 `ORDER BY` 최적화가 어렵다.  
3. **충돌(해시 충돌) 발생 가능**: 해시 충돌이 발생하면 추가 연산이 필요해 성능이 저하될 수 있다.  
4. **비효율적인 디스크 I/O**: 해시 인덱스는 일반적으로 메모리 기반으로 동작하는데, DB에서는 대량의 데이터를 디스크에서 읽어야 하므로 트리 구조가 더 적합하다.  

결론적으로, 해시 테이블은 **단순한 키-값 조회에는 유용하지만, 범위 검색과 정렬이 중요한 데이터베이스에서는 적절하지 않다**.  

---

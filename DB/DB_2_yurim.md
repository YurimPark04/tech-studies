# 데이터베이스 인덱스, SQL 인젝션 정리

## 1. 인덱스는 어떤 알고리즘으로 동작하나요?
인덱스는 데이터를 빠르게 검색하기 위해 **트리 구조 (B-Tree, B+Tree)** 또는 **해시 테이블**, **비트맵 인덱스** 와 같은 알고리즘을 사용합니다. 
- 계층적 구조를 가지는 **트리 구조**는 범위 검색에 효율적이며,  
- 키-값 매핑을 이용하는 **해시 테이블 구조**는 특정 값을 빠르게 찾을 수 있지만, 범위 검색에는 적합하지 않다는 특징이 있습니다.   
- 마지막으로, **비트맵 인덱스** 는 값이 제한적인 경우(예: 성별, 국가 코드)에 유용하며, 특정 조건의 데이터를 빠르게 필터링할 수 있습니다.
일반적으로 관계형 DB에서는 B-Tree 계열이 가장 많이 사용됩니다. 
---

## 2. 그렇다면, B-Tree 알고리즘에 대해 간략히 설명해주세요
B-Tree는 **균형 트리(Balanced Tree)**로, 각 노드에 여러 개의 키(key)와 자식 노드(child)가 존재하는 구조를 가집니다.
- 이진 탐색 트리보다 **트리의 높이가 낮아** 검색 속도가 빠르다는 특징을 가지고 있고, 
- 노드가 가득 차게 되면 **분할(split)**, 너무 적어지면 **병합(merge)**이 발생하여 항상 균형을 유지합니다.
- 쿼리상, 부등호 검색과 같이 범위 검색과 정렬이 필요할 때 매우 효율적인 알고리즘이라고 할 수 있습니다.  

### 2-1. B+Tree 알고리즘에 대해서도 간략히 알고 있다면, 설명해주세요
간단하게 말씀드리자면, B+Tree는 B-Tree의 확장 버전입니다. **리프 노드(leaf node)들만 데이터 값을 저장**하며, **리프 노드끼리 연결된 구조** 를 가집니다.  
- **특징:**  
  - 그렇기 때문에, 모든 데이터가 **리프 노드에 저장**되므로 검색 속도가 일정하며,  
  - **Linked List 형태**로 연결되어 있어 **범위 검색(range query)** 에 최적화되어 있습니다. 
  - 특히, 내부 노드는 **오직 키(key)만 저장**하므로, 같은 높이의 B-Tree보다 **더 많은 키를 저장**할 수 있습니다. 
이러한 이유 때문에, MySQL과 같은 DBMS에서 B+Tree 인덱스를 많이 사용하기도 합니다. 
---

## 3. 인덱스 알고리즘으로는 해시테이블도 있는데, 왜 해시테이블은 선호되지 않나요?
해시 인덱스는 특정 키 값을 빠르게 찾을 때 유용하지만, RDBMS의 전형적인 **검색 패턴에 적합하지 않기 때문입니다**.  
1. 해시는 특정 키에 대한 값만 찾을 수 있고, `BETWEEN`, 혹은 부등호와 같은 범위 검색이 불가능합니다. (**범위 검색이 불가능**)
2. 또한, 해시 테이블은 내부적으로 순서를 보장하지 않아 `ORDER BY` 최적화가 어렵고,  (**정렬 지원 X**)
3. 해시 충돌이 발생하면 추가 연산이 필요해 성능이 저하될 수 있습니다 (**충돌(해시 충돌) 발생 가능**)
결론적으로, 해시 테이블은 **단순 키-값 조회에는 유용하지만, 범위 검색과 정렬이 중요한 데이터베이스에서는 적절하지 않다는 특징을 가집니다.**  

---

## 4. PK(Primary Key)에 대해서도 인덱스 설정을 해줘야 할까요?
별도로 PK에 인덱스를 설정하지 않아도 되지만, 만약 다른 인덱스를 사용하고 싶다면 명시적으로 설정이 필요할 수 있습니다.
네, **PK에는 자동으로 클러스터드 인덱스(Clustered Index)가 설정**됩니다.  
- RDBMS에서는 **기본 키(PK)** 를 설정하면 **PK는 자동으로 클러스터드 인덱스가 생성** 되어 빠른 조회를 지원합니다.  
- 대부분의 DBMS(MySQL, PostgreSQL, SQL Server 등)에서는 **PK가 곧 클러스터드 인덱스**로 작동하며, 데이터를 특정 순서대로 저장합니다.

---

## 5. 인덱스가 데이터의 물리적 저장에도 영향을 미치나요?
네, **클러스터드 인덱스(Clustered Index)는 데이터의 물리적 저장 순서를 결정**합니다.  
- **클러스터드 인덱스가 있는 경우** 에는, 데이터가 해당 인덱스의 정렬 순서에 따라 **실제 디스크에 저장**됩니다.  
- **비클러스터드 인덱스(Non-Clustered Index)의 경우** 에는 데이터가 별도로 저장되며, 인덱스에는 **데이터의 위치만 저장**됩니다.  

---

## 6. NoSQL은 인덱스를 가지고 있나요? 만약 있다면, RDDBMS와의 차이는 무엇일까요?
네, 많은 NoSQL 데이터베이스도 인덱스를 지원하지만, **RDBMS의 인덱스와는 구조와 방식이 다릅니다.**  
- **MongoDB** 의 경우, 기본적으로 `_id` 필드가 자동으로 **B-Tree 기반 인덱스**로 설정되는 반면, 
- **Redis** 의 경우에는 기본적인 인덱스를 제공하지 않습니다. 하지만, 개발자가 데이터 구조(Hash, Sorted Set)를 활용하여 인덱싱 기능을 구현할 수 있습니다.   
RDBMS의 인덱스는 빠른 검색, 정렬 최적화에 목적이 있는 반면, NoSQL의 인덱스는 분산 환경에서의 효율적인 조회를 위한 인덱스가 있다고 볼 수 있습니다
---

## 7. SQL 인젝션은 무엇인가요??
SQL 인젝션은 **사용자가 입력한 데이터가 SQL 쿼리로 실행되도록 유도하여 DB를 조작하는 공격 기법** 입니다. 
- 공격자는 입력 필드나 URL 파라미터에 **SQL 코드를 삽입하여** DB의 데이터를 **조회하거나 조작**할 수 있고, 
- 주로 **웹 애플리케이션의 보안 취약점**을 이용하여 발생하며, **ORM을 사용하거나, 입력 검증** 과 같은 방법을 통해 방어할 수 있습니다. 


## 8. Table Full Scan 과 Index Range Scan의 차이점은 무엇인가요?
Table Full Scan 은 **인덱스를 사용하지 않고 테이블의 모든 행을 읽는 방식** 입니다.
- `WHERE` 조건에 **인덱스를 활용할 수 없는 경우** 발생하며,
- 테이블이 클수록 성능이 저하됩니다.
  면, Index Range Scan 은 **인덱스를 사용해서 특정 범위의 데이터를 조회하는 방식** 입니다.
- 범위 조건 (`>`, `<`, `BETWEEN`, `LIKE 'abc%'`)이 포함된 경우 사용됩니다. 

